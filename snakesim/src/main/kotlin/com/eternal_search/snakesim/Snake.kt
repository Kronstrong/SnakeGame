package com.eternal_search.snakesim

abstract class Snake(
	protected val gameView: SnakeMap,
	x: Int, y: Int, length: Int = 4,
	horizontal: Boolean = true, reversed: Boolean = true
) {
	val chunks = mutableListOf<Chunk>()
	protected val minX: Int = 1
	protected val minY: Int = 1
	protected val maxX: Int get() = gameView.cellCountX - 2
	protected val maxY: Int get() = gameView.cellCountY - 2
	var eatCallback: (() -> Unit)? = null
	var dieCallback: (() -> Unit)? = null
	val score: Int get() = chunks.size - 4
	
	init {
		for (i in 0 until length) {
			if (horizontal) {
				chunks.add(
					Chunk(
						if (reversed) x - i else x + i,
						y,
						false
					)
				)
			} else {
				chunks.add(
					Chunk(
						x,
						if (reversed) y - i else x + i,
						false
					)
				)
			}
		}
	}
	
	private fun move(dx: Int, dy: Int): Boolean {
		if (dx == 0 && dy == 0) {
			return false
		}
		
		synchronized(gameView) {
			chunks.first().let {
				var p = Point(
					it.x + dx,
					it.y + dy
				)
				if (gameView.noWalls) {
					p = Point(
						when (p.x) {
							minX - 1 -> maxX
							maxX + 1 -> minX
							else -> p.x
						},
						when (p.y) {
							minY - 1 -> maxY
							maxY + 1 -> minY
							else -> p.y
						}
					)
				} else {
					p = Point(
						p.x.coerceIn(minX, maxX),
						p.y.coerceIn(minY, maxY)
					)
				}
				if (chunks.size > 1) {
					if (chunks[1].let { it.x == p.x && it.y == p.y }) {
						if (gameView.allowIdle) {
							return false
						}
						p = Point(
							(it.x - dx).coerceIn(minX, maxX),
							(it.y - dy).coerceIn(minY, maxY)
						)
					}
				}
				
				val food = gameView.eatFood(p.x, p.y)
				chunks.add(0, Chunk(p.x, p.y, food != null))
				if (food != null) {
					eatCallback?.invoke()
					if (food.autoGenerated) {
						gameView.generateFood()
					}
				} else {
					chunks.removeAt(chunks.lastIndex)
				}
				
				val fail = (gameView.snakes.flatMap {
					(if (it === this)
						it.chunks.drop(1)
					else
						it.chunks).map { Point(it.x, it.y) }
				} + gameView.walls).firstOrNull {
					it.x == p.x && it.y == p.y
				} != null
				if (fail) {
					dieCallback?.invoke()
				}
			}
		}
		return true
	}
	
	abstract fun step(): Point
	
	fun makeStep(): Boolean {
		val direction = step()
		return move(direction.x, direction.y)
	}
	
	data class Chunk(
		val x: Int,
		val y: Int,
		val fat: Boolean
	)
}
